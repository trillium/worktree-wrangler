{
	"project": "Worktree Wrangler TypeScript Port",
	"description": "Active development stories for porting Worktree Wrangler from zsh to TypeScript",
	"stories": [
		{
			"id": "story-1",
			"title": "Phase 1: Core Infrastructure Setup",
			"description": "Set up TypeScript project structure with all necessary build tooling, type definitions, and base interfaces as outlined in TYPESCRIPT-PORT-DESIGN.md Phase 1",
			"priority": "high",
			"passes": false,
			"acceptanceCriteria": [
				"TypeScript compilation configured and working",
				"All type definitions from design doc implemented",
				"Base interfaces and abstract classes created",
				"Utility modules (exec, filesystem, validation) implemented with tests",
				"Build produces working executable"
			],
			"dependencies": [],
			"attempts": []
		},
		{
			"id": "story-2",
			"title": "Scaffold modular file structure with per-function organization",
			"description": "Create a well-organized directory and file structure where each major function lives in its own dedicated file. This ensures maintainability by keeping files under 250 lines and makes the codebase easy to navigate. Each file should contain one primary function with related helpers, following the single responsibility principle. The structure should support the Phase 2-5 implementation as outlined in TYPESCRIPT-PORT-DESIGN.md.",
			"priority": "high",
			"passes": false,
			"info": "This scaffolding story establishes the organizational foundation that will make implementing Phases 2-5 straightforward. The 250-line limit ensures no file becomes unwieldy. Use the TYPESCRIPT-PORT-DESIGN.md architecture section as guidance for logical grouping.",
			"acceptanceCriteria": [
				"Create src/ directory structure with logical grouping (commands/, core/, utils/, cli/, config/)",
				"Each major worktree operation (create, switch, remove, list, cleanup) lives in its own file under src/commands/",
				"Core business logic (worktree detection, PR integration, path resolution) separated into src/core/",
				"Utility functions (filesystem, git exec, validation) organized in src/utils/",
				"No single file exceeds 250 lines of code (excluding tests)",
				"Each file has a clear single responsibility and focused API",
				"Index files (index.ts) created for clean imports from each directory",
				"File naming follows kebab-case convention (e.g., worktree-create.ts, pr-detection.ts)",
				"Directory structure documented in README or architecture doc"
			],
			"dependencies": [
				"story-1"
			],
			"attempts": []
		},
		{
			"id": "story-3",
			"title": "Utility Layer: Core utilities (exec, filesystem, validation, clipboard)",
			"description": "Implement foundational utility modules that will be used throughout the application.\n\nModules to Implement:\n\nsrc/utils/exec.ts:\n- executeCommand(command: string, args: string[], options?): Promise<Result<string>>\n- executeCommandSync(command: string, args: string[]): Result<string>\n- Error handling with stderr capture\n- Working directory support\n\nsrc/utils/filesystem.ts:\n- fileExists(path: string): Promise<boolean>\n- directoryExists(path: string): Promise<boolean>\n- readFile(path: string): Promise<Result<string>>\n- writeFile(path: string, content: string): Promise<Result<void>>\n- expandTilde(path: string): string\n- ensureDirectory(path: string): Promise<Result<void>>\n\nsrc/utils/validation.ts:\n- isValidPath(path: string): boolean\n- isValidProjectName(name: string): boolean\n- isValidWorktreeName(name: string): boolean\n- sanitizeInput(input: string): string\n\nsrc/utils/clipboard.ts:\n- copyToClipboard(text: string): Promise<Result<void>>\n- Detect platform (macOS pbcopy, Linux xclip/wl-copy, Windows clip)\n- Graceful fallback if no clipboard available",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.1 (Utilities). These utilities provide the foundation for all other modules. Keep each focused and under 250 lines.",
			"acceptanceCriteria": [
				"All four utility files created in src/utils/",
				"Each file stays under 250 lines",
				"Unit tests in tests/utils/ covering normal cases for all functions",
				"Unit tests cover error cases (missing files, invalid paths, command failures)",
				"Unit tests cover edge cases (empty strings, special characters, tilde expansion)",
				"executeCommand handles both success and error cases with Result type",
				"filesystem utilities handle missing files/directories gracefully",
				"clipboard utility works on macOS (pbcopy tested)",
				"All exports use TypeScript interfaces/types",
				"100% test coverage for utility modules"
			],
			"dependencies": [
				"story-1",
				"story-2"
			],
			"attempts": []
		},
		{
			"id": "story-4",
			"title": "Configuration Layer: ConfigManager and defaults",
			"description": "Implement configuration management system for user settings.\n\nsrc/config/ConfigManager.ts:\n- loadConfig(): Promise<Result<Config>>\n- saveConfig(config: Config): Promise<Result<void>>\n- getProjectsDir(): string\n- setProjectsDir(path: string): Promise<Result<void>>\n- resetConfig(): Promise<Result<void>>\n- validateConfig(config: Config): Result<void>\n\nsrc/config/defaults.ts:\n- DEFAULT_PROJECTS_DIR constant\n- DEFAULT_CONFIG object\n- Config type definition\n\nConfiguration file: ~/.local/share/worktree-wrangler/config\nFormat: key=value (projects_dir=/path/to/projects)",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.2 (Configuration). The config system must support migration from zsh version and handle missing/invalid config gracefully.",
			"acceptanceCriteria": [
				"ConfigManager.ts and defaults.ts created in src/config/",
				"Each file stays under 250 lines",
				"Config loaded from ~/.local/share/worktree-wrangler/config",
				"Parse key=value format correctly",
				"Handle missing config file (use defaults)",
				"Handle invalid paths (validation and error messages)",
				"Validate paths exist before saving",
				"Unit tests for loadConfig with missing file",
				"Unit tests for saveConfig and resetConfig",
				"Unit tests for invalid config values",
				"Config type exported and used throughout application"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3"
			],
			"attempts": []
		},
		{
			"id": "story-5",
			"title": "Configuration Layer: ScriptManager for per-repo scripts",
			"description": "Implement per-repository script management for setup and archive scripts.\n\nsrc/config/ScriptManager.ts:\n- getSetupScript(repo: string): Promise<Result<string | null>>\n- setSetupScript(repo: string, scriptPath: string): Promise<Result<void>>\n- clearSetupScript(repo: string): Promise<Result<void>>\n- getArchiveScript(repo: string): Promise<Result<string | null>>\n- setArchiveScript(repo: string, scriptPath: string): Promise<Result<void>>\n- clearArchiveScript(repo: string): Promise<Result<void>>\n- validateScriptPath(path: string): Result<void>\n\nStorage location: ~/.local/share/worktree-wrangler/repos/{repo}.setup_script and {repo}.archive_script\nValidation: Script file must exist and be executable",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.2 (Configuration). Scripts are stored per-repository and must be validated before execution.",
			"acceptanceCriteria": [
				"ScriptManager.ts created in src/config/",
				"File stays under 250 lines",
				"Storage in ~/.local/share/worktree-wrangler/repos/ directory",
				"Filename format: {repo}.setup_script and {repo}.archive_script",
				"Validate script exists before setting",
				"Validate script is executable (chmod +x check)",
				"Return null if no script configured",
				"Unit tests for get/set/clear operations",
				"Unit tests for missing scripts",
				"Unit tests for non-executable scripts",
				"Integration with ConfigManager for base path"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3",
				"story-4"
			],
			"attempts": []
		},
		{
			"id": "story-6",
			"title": "Git Layer: GitClient wrapper",
			"description": "Implement git command wrapper with dependency injection and Result pattern.\n\nsrc/git/GitClient.ts:\n- getCurrentBranch(repoPath: string): Promise<Result<string>>\n- getCommitSha(repoPath: string, ref?: string): Promise<Result<string>>\n- getStatus(repoPath: string): Promise<Result<GitStatus>>\n- createWorktree(mainRepo: string, path: string, branch: string): Promise<Result<void>>\n- removeWorktree(path: string, force: boolean): Promise<Result<void>>\n- listWorktrees(repoPath: string): Promise<Result<WorktreeInfo[]>>\n- hasUncommittedChanges(repoPath: string): Promise<Result<boolean>>\n- hasUnpushedCommits(repoPath: string): Promise<Result<boolean>>\n\nUse dependency injection for command executor (testable with mocks).",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.3 (Git Operations). GitClient is a core abstraction that all worktree operations depend on. Must be thoroughly tested with mocked git commands.",
			"acceptanceCriteria": [
				"GitClient.ts created in src/git/",
				"File stays under 250 lines (split if needed)",
				"Dependency injection pattern for executor",
				"All methods return Result type for error handling",
				"GitStatus and WorktreeInfo types defined",
				"Unit tests with mocked git commands for all methods",
				"Unit tests for git command failures",
				"Unit tests for parsing git output",
				"Error messages include stderr from git",
				"Support for both absolute and relative paths"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3"
			],
			"attempts": []
		},
		{
			"id": "story-7",
			"title": "Git Layer: RepositoryResolver",
			"description": "Implement project path resolution supporting flat and nested structures.\n\nsrc/git/RepositoryResolver.ts:\n- listValidProjects(projectsDir: string): Promise<Result<string[]>>\n- resolveProjectRoot(projectsDir: string, projectName: string): Promise<Result<string>>\n- isGitRepository(path: string): Promise<boolean>\n- findProjectByName(projectsDir: string, projectName: string): Promise<Result<string>>\n\nSupport:\n- Flat structure: ~/development/project1/, ~/development/project2/\n- Nested structure: ~/development/category1/project1/, ~/development/category2/project2/\n- Mixed structures",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.3 (Git Operations). The resolver must handle both flat and nested project structures as many users have organized their projects in subdirectories.",
			"acceptanceCriteria": [
				"RepositoryResolver.ts created in src/git/",
				"File stays under 250 lines",
				"listValidProjects finds all git repos recursively",
				"resolveProjectRoot handles flat structure",
				"resolveProjectRoot handles nested structure (one level deep)",
				"isGitRepository checks for .git directory or file",
				"Unit tests with temporary directory structures",
				"Unit tests for flat, nested, and mixed structures",
				"Unit tests for non-existent projects",
				"Unit tests for non-git directories",
				"Performance: limit recursion depth to 2 levels"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3"
			],
			"attempts": []
		},
		{
			"id": "story-8",
			"title": "Git Layer: WorktreeManager CRUD operations",
			"description": "Implement core worktree management operations.\n\nsrc/git/WorktreeManager.ts:\n- findWorktreePath(project: string, worktree: string, projectsDir: string): Promise<Result<string | null>>\n- resolveMainRepoFromWorktree(worktreePath: string): Promise<Result<string>>\n- getWorktreeInfo(worktreePath: string): Promise<Result<WorktreeInfo>>\n- createWorktree(mainRepo: string, worktree: string, branch: string): Promise<Result<string>>\n- removeWorktree(path: string, force: boolean): Promise<Result<void>>\n- listWorktrees(projectRoot: string): Promise<Result<WorktreeInfo[]>>\n\nWorktree search locations:\n1. ~/development/worktrees/{project}/{worktree}/ (standard)\n2. ~/projects/core-wts/{project}/{worktree}/ (legacy)\n3. Nested: ~/development/{category}/{project}/worktrees/{worktree}/\n\nWorktreeInfo type:\n- path: string\n- branch: string\n- commit: string\n- isDirty: boolean\n- lastActivity: Date",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.3 (Git Operations). WorktreeManager is the core of the application. May need splitting into multiple files if >250 lines.",
			"acceptanceCriteria": [
				"WorktreeManager.ts created in src/git/",
				"File stays under 250 lines or split logically",
				"findWorktreePath searches all three locations",
				"resolveMainRepoFromWorktree parses git worktree output",
				"getWorktreeInfo extracts branch, status, last activity",
				"createWorktree uses GitClient to create worktree",
				"removeWorktree handles force flag correctly",
				"listWorktrees returns info for all worktrees",
				"Unit tests for all CRUD operations",
				"Unit tests for all search locations",
				"Unit tests for missing worktrees",
				"Integration with GitClient",
				"WorktreeInfo type exported and used consistently"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3",
				"story-6"
			],
			"attempts": []
		},
		{
			"id": "story-9",
			"title": "GitHub Layer: GitHubClient wrapper",
			"description": "Implement GitHub CLI (gh) wrapper with authentication checking.\n\nsrc/github/GitHubClient.ts:\n- checkAuth(): Promise<Result<boolean>>\n- executeGhCommand(args: string[]): Promise<Result<string>>\n- getPRStatus(repoPath: string, branch: string): Promise<Result<PRStatus | null>>\n- listPRs(repoPath: string, options?: ListPROptions): Promise<Result<PR[]>>\n- getPRByCommit(repoPath: string, sha: string): Promise<Result<PR | null>>\n\nTypes:\n- PRStatus: { number: number, title: string, url: string, state: string }\n- PR: Extended info including author, labels, etc.\n- ListPROptions: { state?: 'open' | 'closed' | 'merged' | 'all', limit?: number }",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.4 (GitHub Integration). GitHubClient abstracts gh CLI and must gracefully handle unauthenticated state.",
			"acceptanceCriteria": [
				"GitHubClient.ts created in src/github/",
				"File stays under 250 lines",
				"checkAuth verifies gh CLI is authenticated",
				"executeGhCommand handles gh CLI errors",
				"getPRStatus uses gh pr status command",
				"listPRs uses gh pr list with filters",
				"getPRByCommit uses gh pr list --search",
				"Unit tests with mocked gh commands",
				"Unit tests for unauthenticated state",
				"Unit tests for gh CLI not installed",
				"Unit tests for API errors",
				"PRStatus and PR types exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3"
			],
			"attempts": []
		},
		{
			"id": "story-10",
			"title": "GitHub Layer: PRDetector with 4 fallback methods",
			"description": "Implement robust PR detection with multiple fallback strategies.\n\nsrc/github/PRDetector.ts:\n- detectPR(repoPath: string, worktreePath: string): Promise<Result<PRStatus | null>>\n\nDetection methods (in order):\n1. Branch format matching: Try 'branch', 'origin/branch', 'short-branch'\n2. Context-aware gh pr status: Run from worktree directory\n3. All PRs filtering: Get all PRs and match by branch name with partial matching\n4. Commit-based lookup: Get commit SHA and search by commit\n\nEach method should be a separate private function for testability.\n\nHandle edge cases:\n- Branch with no PR\n- Multiple PRs for same branch\n- Detached HEAD state\n- Network/API failures",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.4 (GitHub Integration). The 4-method fallback is critical for reliability. This is one of the most important modules as PR detection must work in diverse scenarios.",
			"acceptanceCriteria": [
				"PRDetector.ts created in src/github/",
				"File stays under 250 lines",
				"Implement method 1: branch format matching",
				"Implement method 2: context-aware gh pr status",
				"Implement method 3: all PRs filtering with partial match",
				"Implement method 4: commit SHA search",
				"Each method is a separate testable function",
				"detectPR tries all methods in order until success",
				"Unit tests for each detection method",
				"Unit tests for branch with no PR",
				"Unit tests for multiple PRs (same branch)",
				"Unit tests for detached HEAD",
				"Unit tests for API failures",
				"Integration with GitHubClient"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3",
				"story-9"
			],
			"attempts": []
		},
		{
			"id": "story-11",
			"title": "GitHub Layer: PRParser for JSON responses",
			"description": "Implement parser for different GitHub CLI JSON response formats.\n\nsrc/github/PRParser.ts:\n- parsePRStatus(json: string): Result<PRStatus | null>\n- parsePRList(json: string): Result<PR[]>\n- extractPRNumber(json: any): number | null\n- extractPRState(json: any): string | null\n\nHandle different JSON formats:\n1. gh pr status: { currentBranch: { state: '...', number: 123 } }\n2. gh pr list single: [{ state: '...', number: 123 }]\n3. gh pr list multiple: [{ state: '...', number: 123 }, ...]\n4. Direct PR object: { state: '...', number: 123 }\n\nRobust parsing:\n- Handle missing fields gracefully\n- Validate required fields exist\n- Type-safe extraction",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.4 (GitHub Integration). The zsh version had brittle jq parsing. This TypeScript version should be much more robust with proper error handling.",
			"acceptanceCriteria": [
				"PRParser.ts created in src/github/",
				"File stays under 250 lines",
				"Parse .currentBranch.state format",
				"Parse .[0].state array format",
				"Parse .state direct format",
				"Extract PR number, title, URL, state",
				"Handle missing fields (return null)",
				"Handle invalid JSON (return error)",
				"Unit tests with real gh response fixtures",
				"Unit tests for each JSON format variant",
				"Unit tests for malformed JSON",
				"Unit tests for missing required fields",
				"Type-safe with proper TypeScript types"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-9"
			],
			"attempts": []
		},
		{
			"id": "story-12",
			"title": "GitHub Layer: PRLinkFormatter with emoji sizing",
			"description": "Implement PR link formatting with size-based emojis.\n\nsrc/github/PRLinkFormatter.ts:\n- formatPRLink(pr: PR, repoPath: string): Promise<Result<string>>\n- calculatePRSize(pr: PR, repoPath: string): Promise<Result<PRSize>>\n- getSizeEmoji(size: PRSize): string\n\nPR size calculation:\n- Get diff stats: additions + deletions\n- Size categories:\n  - ant üêú: <50 lines\n  - mouse üê≠: 50-149 lines\n  - dog üêï: 150-599 lines\n  - lion ü¶Å: 600-1999 lines\n  - whale üêã: ‚â•2000 lines\n\nOutput format: {emoji} [PR Title](PR URL)\nExample: üê≠ [Fix login bug](https://github.com/user/repo/pull/123)",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.4 (GitHub Integration). The emoji sizing is a nice UX feature that helps developers quickly gauge PR complexity.",
			"acceptanceCriteria": [
				"PRLinkFormatter.ts created in src/github/",
				"File stays under 250 lines",
				"calculatePRSize gets additions + deletions from gh",
				"Size thresholds: ant <50, mouse <150, dog <600, lion <2000, whale ‚â•2000",
				"getSizeEmoji returns correct emoji for each category",
				"formatPRLink produces markdown format",
				"Unit tests for all size categories",
				"Unit tests for edge cases (0 lines, huge PRs)",
				"Unit tests for API failures (fallback behavior)",
				"Mock gh CLI responses in tests",
				"PRSize type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-9"
			],
			"attempts": []
		},
		{
			"id": "story-13",
			"title": "Tracking Layer: RecentTracker and TrackerStorage",
			"description": "Implement worktree usage tracking with file-based storage.\n\nsrc/tracking/RecentTracker.ts:\n- trackUsage(project: string, worktree: string): Promise<Result<void>>\n- getRecentWorktrees(limit?: number): Promise<Result<RecentEntry[]>>\n- clearHistory(): Promise<Result<void>>\n\nsrc/tracking/TrackerStorage.ts:\n- readEntries(): Promise<Result<RecentEntry[]>>\n- writeEntries(entries: RecentEntry[]): Promise<Result<void>>\n- pruneEntries(entries: RecentEntry[], maxEntries: number): RecentEntry[]\n\nStorage format: ~/.local/share/worktree-wrangler/recent\nFormat: timestamp|project|worktree (one per line)\nKeep last 50 entries\n\nRecentEntry type:\n- timestamp: Date\n- project: string\n- worktree: string\n- exists: boolean (check if path still exists)",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.5 (Tracking and Scripts). Recent tracking helps users quickly return to recently-used worktrees.",
			"acceptanceCriteria": [
				"RecentTracker.ts created in src/tracking/",
				"TrackerStorage.ts created in src/tracking/",
				"Each file stays under 250 lines",
				"Storage in ~/.local/share/worktree-wrangler/recent",
				"Format: timestamp|project|worktree per line",
				"trackUsage appends new entry",
				"pruneEntries keeps only last 50",
				"getRecentWorktrees returns sorted by timestamp",
				"Check if worktree path still exists (exists field)",
				"Unit tests for tracking and retrieval",
				"Unit tests for pruning old entries",
				"Unit tests for missing/deleted worktrees",
				"Unit tests for file corruption handling",
				"RecentEntry type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3"
			],
			"attempts": []
		},
		{
			"id": "story-14",
			"title": "Tracking Layer: ScriptExecutor and ScriptEnvironment",
			"description": "Implement script execution with environment variable setup.\n\nsrc/tracking/ScriptExecutor.ts:\n- executeSetupScript(scriptPath: string, worktreePath: string, project: string): Promise<Result<void>>\n- executeArchiveScript(scriptPath: string, worktreePath: string, project: string): Promise<Result<void>>\n- executeScript(scriptPath: string, env: ScriptEnvironment): Promise<Result<void>>\n\nsrc/tracking/ScriptEnvironment.ts:\n- buildEnvironment(worktreePath: string, project: string, defaultBranch: string): ScriptEnvironment\n- getDefaultBranch(repoPath: string): Promise<Result<string>>\n\nEnvironment variables set:\n- W_WORKSPACE_NAME: worktree name\n- W_WORKSPACE_PATH: full worktree path\n- W_ROOT_PATH: main repo path\n- W_DEFAULT_BRANCH: main/master branch name\n\nScript execution:\n- Run from worktree directory\n- Capture stdout/stderr\n- Handle script failures gracefully",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.5 (Tracking and Scripts). Scripts allow users to customize worktree setup and cleanup with their own automation.",
			"acceptanceCriteria": [
				"ScriptExecutor.ts created in src/tracking/",
				"ScriptEnvironment.ts created in src/tracking/",
				"Each file stays under 250 lines",
				"buildEnvironment sets W_WORKSPACE_NAME, W_WORKSPACE_PATH, W_ROOT_PATH, W_DEFAULT_BRANCH",
				"getDefaultBranch detects main or master",
				"executeScript runs from worktree directory",
				"executeScript captures stdout/stderr",
				"executeSetupScript and executeArchiveScript use executeScript",
				"Unit tests with mock scripts",
				"Unit tests for script failures",
				"Unit tests for environment variable passing",
				"Unit tests for working directory",
				"Integration with ScriptManager for script paths",
				"ScriptEnvironment type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3",
				"story-5",
				"story-6"
			],
			"attempts": []
		},
		{
			"id": "story-15",
			"title": "UI Layer: OutputFormatter with colors",
			"description": "Implement colored terminal output formatting.\n\nsrc/ui/OutputFormatter.ts:\n- info(message: string): string\n- error(message: string): string\n- success(message: string): string\n- warning(message: string): string\n- heading(message: string): string\n- hint(message: string): string\n- bold(message: string): string\n- dim(message: string): string\n- code(message: string): string\n\nUse chalk or similar library for cross-platform color support.\n\nColor scheme:\n- info: blue\n- error: red\n- success: green\n- warning: yellow\n- heading: bold cyan\n- hint: dim gray\n- code: cyan background",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.6 (UI and Output). Consistent, colorful output improves UX significantly.",
			"acceptanceCriteria": [
				"OutputFormatter.ts created in src/ui/",
				"File stays under 250 lines",
				"Use chalk or similar for colors",
				"info() uses blue color",
				"error() uses red color",
				"success() uses green color",
				"warning() uses yellow color",
				"heading() uses bold cyan",
				"hint() uses dim gray",
				"code() uses cyan background",
				"Unit tests for all formatting methods",
				"Unit tests verify color codes are applied",
				"Support NO_COLOR environment variable",
				"Cross-platform compatibility"
			],
			"dependencies": [
				"story-1",
				"story-2"
			],
			"attempts": []
		},
		{
			"id": "story-16",
			"title": "UI Layer: TableFormatter and ErrorFormatter",
			"description": "Implement table formatting and user-friendly error messages.\n\nsrc/ui/TableFormatter.ts:\n- formatTable(data: TableData): string\n- formatList(items: string[]): string\n- formatKeyValue(pairs: Record<string, string>): string\n\nsrc/ui/ErrorFormatter.ts:\n- formatError(error: Error, context?: string): string\n- formatGitError(stderr: string): string\n- formatGitHubError(error: string): string\n- suggestSolution(errorType: ErrorType): string\n\nError formatting:\n- Convert technical errors to user-friendly messages\n- Suggest solutions (e.g., 'Run: gh auth login')\n- Include relevant context\n- Color-code error components",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.6 (UI and Output). Good error messages with solutions are critical for UX.",
			"acceptanceCriteria": [
				"TableFormatter.ts created in src/ui/",
				"ErrorFormatter.ts created in src/ui/",
				"Each file stays under 250 lines",
				"formatTable handles aligned columns",
				"formatList uses bullets or numbers",
				"formatKeyValue aligns keys and values",
				"formatError converts Error objects to readable strings",
				"formatGitError parses git stderr",
				"formatGitHubError handles gh CLI errors",
				"suggestSolution provides actionable next steps",
				"Unit tests for table formatting",
				"Unit tests for various error types",
				"Unit tests for solution suggestions",
				"Integration with OutputFormatter for colors",
				"TableData and ErrorType types exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-17",
			"title": "Command: ListCommand implementation",
			"description": "Implement --list command to show all worktrees.\n\nsrc/commands/ListCommand.ts:\n- execute(options?: ListOptions): Promise<Result<void>>\n- formatWorktreeList(projects: ProjectWorktrees[]): string\n\nFunctionality:\n- Show worktrees from all locations (legacy, standard, nested)\n- Group by project with headers\n- Display: worktree name, branch, status (clean/dirty), last activity\n- Show total count\n- Support filtering by project (optional)\n\nOutput format:\nProject: myproject\n  feature-1 (user/feature-1) - clean - 2 days ago\n  bug-fix (user/bug-fix) - dirty - 1 hour ago\n\nTotal: 2 worktrees",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). ListCommand is a frequently-used command for getting worktree overview.",
			"acceptanceCriteria": [
				"ListCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Show worktrees from all search locations",
				"Group worktrees by project",
				"Display: name, branch, clean/dirty status, last activity",
				"Show total worktree count",
				"Support optional project filter",
				"Use OutputFormatter for colors",
				"Use TableFormatter for layout",
				"Unit tests with mock WorktreeManager",
				"Unit tests for empty projects",
				"Unit tests for filtering",
				"Integration test with real git repos",
				"ListOptions type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-8",
				"story-15",
				"story-16"
			],
			"attempts": []
		},
		{
			"id": "story-18",
			"title": "Command: StatusCommand implementation",
			"description": "Implement --status command to show git status for worktrees.\n\nsrc/commands/StatusCommand.ts:\n- execute(options?: StatusOptions): Promise<Result<void>>\n- formatStatus(worktree: string, status: GitStatus): string\n\nFunctionality:\n- Show git status for all worktrees (or filtered by project)\n- Only display worktrees with changes\n- Show: modified files, untracked files, staged files\n- Support verbose mode (show full git status)\n\nOutput format:\nWorktree: myproject/feature-1\n  Modified: src/index.ts, src/config.ts\n  Untracked: test.js\n\nWorktree: myproject/bug-fix\n  Staged: README.md",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). StatusCommand helps users quickly see which worktrees have pending changes.",
			"acceptanceCriteria": [
				"StatusCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Show status for all/specific project worktrees",
				"Only display worktrees with changes",
				"Show modified, untracked, and staged files",
				"Support verbose mode for full git status output",
				"Support project filter",
				"Use OutputFormatter for colors",
				"Unit tests with mock GitClient",
				"Unit tests for clean worktrees (no output)",
				"Unit tests for dirty worktrees",
				"Unit tests for filtering",
				"StatusOptions type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-6",
				"story-8",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-19",
			"title": "Command: RecentCommand implementation",
			"description": "Implement --recent command to show recently-used worktrees.\n\nsrc/commands/RecentCommand.ts:\n- execute(options?: RecentOptions): Promise<Result<void>>\n- formatRecentList(entries: RecentEntry[]): string\n\nFunctionality:\n- Display last 10 recently used worktrees (configurable limit)\n- Show: timestamp, project, worktree, exists status\n- Mark deleted worktrees with indicator\n- Sort by most recent first\n\nOutput format:\n2 hours ago - myproject/feature-1 ‚úì\n1 day ago - myproject/bug-fix ‚úì\n3 days ago - oldproject/test (deleted) ‚úó",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). RecentCommand provides quick access to frequently-used worktrees.",
			"acceptanceCriteria": [
				"RecentCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Display last 10 worktrees by default",
				"Support configurable limit",
				"Show timestamp, project, worktree name",
				"Mark deleted worktrees with ‚úó indicator",
				"Mark existing worktrees with ‚úì indicator",
				"Sort by most recent first",
				"Use OutputFormatter for colors",
				"Unit tests with mock RecentTracker",
				"Unit tests for empty history",
				"Unit tests for deleted worktrees",
				"Unit tests for custom limits",
				"RecentOptions type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-13",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-20",
			"title": "Command: VersionCommand and HelpCommand",
			"description": "Implement --version and --help commands.\n\nsrc/commands/VersionCommand.ts:\n- execute(): Promise<Result<void>>\n- Display version number and build info\n\nsrc/commands/HelpCommand.ts:\n- execute(): Promise<Result<void>>\n- Display comprehensive help text\n\nHelp sections:\n- Usage examples\n- Command reference\n- Configuration options\n- Script configuration\n- GitHub integration notes\n- Troubleshooting tips\n\nVersion info:\n- Version number (from package.json)\n- Build date\n- Node version\n- Platform",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). Help and version are essential for usability and debugging.",
			"acceptanceCriteria": [
				"VersionCommand.ts created in src/commands/",
				"HelpCommand.ts created in src/commands/",
				"Each file stays under 250 lines",
				"Version displays package.json version",
				"Help shows all command usage",
				"Help includes configuration options",
				"Help includes script setup examples",
				"Help includes GitHub auth notes",
				"Help includes troubleshooting section",
				"Use OutputFormatter for colors and formatting",
				"Unit tests for version output",
				"Unit tests for help output completeness",
				"Help text is comprehensive but not overwhelming"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-21",
			"title": "Command: RemoveCommand implementation",
			"description": "Implement --rm command to remove worktrees.\n\nsrc/commands/RemoveCommand.ts:\n- execute(project: string, worktree: string, options?: RemoveOptions): Promise<Result<void>>\n- checkWorktreeStatus(path: string): Promise<Result<WorktreeStatus>>\n- promptForConfirmation(path: string, status: WorktreeStatus): Promise<boolean>\n\nFunctionality:\n- Remove specified worktree\n- Check for uncommitted changes (error unless --force)\n- Check for untracked files (list them, error unless --force)\n- Run archive script before removal (if configured)\n- Support --force / -f flag to skip checks\n- Confirm before removal (unless --force)\n\nError messages:\n- List uncommitted changes and untracked files\n- Suggest: git commit or use --force\n- Show archive script output if run",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). RemoveCommand must be safe by default but support force removal when needed.",
			"acceptanceCriteria": [
				"RemoveCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Check for uncommitted changes (error unless --force)",
				"Check for untracked files (list them, error unless --force)",
				"Run archive script before removal if configured",
				"Support --force / -f flag",
				"Prompt for confirmation before removal",
				"Use WorktreeManager.removeWorktree",
				"Use ScriptExecutor for archive script",
				"Unit tests for clean removal",
				"Unit tests for dirty worktree (should error)",
				"Unit tests for force removal",
				"Unit tests for archive script execution",
				"Unit tests for non-existent worktree",
				"RemoveOptions and WorktreeStatus types exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-6",
				"story-8",
				"story-14",
				"story-15",
				"story-16"
			],
			"attempts": []
		},
		{
			"id": "story-22",
			"title": "Command: CleanupCommand implementation",
			"description": "Implement --cleanup command to remove merged PR worktrees.\n\nsrc/commands/CleanupCommand.ts:\n- execute(options?: CleanupOptions): Promise<Result<void>>\n- checkWorktreeEligibility(worktree: WorktreeInfo): Promise<Result<boolean>>\n- cleanupWorktree(worktree: WorktreeInfo): Promise<Result<void>>\n\nFunctionality:\n- Find all worktrees\n- For each worktree: detect PR status\n- Check if PR is merged\n- Check for uncommitted changes (skip if dirty)\n- Check for unpushed commits (skip if unpushed)\n- Run archive script before removal\n- Remove worktree if eligible\n- Track counts: checked, cleaned, skipped\n- Support dry-run mode\n- Support project filter\n\nOutput:\nChecking worktrees...\n‚úì Cleaned: myproject/feature-1 (PR #123 merged)\n‚äò Skipped: myproject/bug-fix (uncommitted changes)\n‚äò Skipped: myproject/wip (no PR found)\n\nSummary: Checked 5, Cleaned 1, Skipped 4",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). CleanupCommand is one of the most valuable features, automating worktree cleanup after PRs are merged.",
			"acceptanceCriteria": [
				"CleanupCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Find all worktrees using WorktreeManager",
				"Detect PR status using PRDetector",
				"Check if PR is merged",
				"Skip if uncommitted changes",
				"Skip if unpushed commits",
				"Run archive script before removal",
				"Track counts: checked, cleaned, skipped",
				"Support dry-run mode (show what would be cleaned)",
				"Support project filter",
				"Show progress with spinners or indicators",
				"Unit tests with mock PRs (merged, open, dirty)",
				"Unit tests for dry-run mode",
				"Unit tests for filtering",
				"Unit tests for archive script execution",
				"CleanupOptions type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-6",
				"story-8",
				"story-10",
				"story-14",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-23",
			"title": "Command: WorktreeCommand (create/switch)",
			"description": "Implement main worktree command for create/switch operations.\n\nsrc/commands/WorktreeCommand.ts:\n- execute(project: string, worktree: string, options?: WorktreeOptions): Promise<Result<void>>\n- createWorktree(project: string, worktree: string): Promise<Result<string>>\n- switchToWorktree(path: string): Promise<Result<void>>\n- executeInWorktree(path: string, command: string[]): Promise<Result<void>>\n\nFunctionality:\n- Create worktree if doesn't exist\n- Branch naming: $USER/$worktree\n- Run setup script after creation (if configured)\n- Switch to worktree (change directory)\n- Track usage in recent file\n- Support command execution mode: w <project> <worktree> <command>\n\nExamples:\n- w myproject feature-1 ‚Üí create/switch to myproject/feature-1\n- w myproject feature-1 git status ‚Üí run git status in worktree\n- w myproject feature-1 code . ‚Üí open VS Code in worktree",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). WorktreeCommand is the primary command users interact with. It must be fast and reliable.",
			"acceptanceCriteria": [
				"WorktreeCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Create worktree if doesn't exist",
				"Use branch naming: $USER/$worktree",
				"Run setup script after creation if configured",
				"Track usage with RecentTracker",
				"Support switching to existing worktree",
				"Support command execution mode (w <project> <worktree> <command>)",
				"Use WorktreeManager for operations",
				"Use ScriptExecutor for setup script",
				"Unit tests for create worktree",
				"Unit tests for switch to existing",
				"Unit tests for command execution",
				"Unit tests for setup script execution",
				"Unit tests for tracking",
				"WorktreeOptions type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-6",
				"story-8",
				"story-13",
				"story-14",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-24",
			"title": "Command: CopyPRLinkCommand implementation",
			"description": "Implement --copy-pr-link command to copy formatted PR link.\n\nsrc/commands/CopyPRLinkCommand.ts:\n- execute(project?: string, worktree?: string): Promise<Result<void>>\n- detectCurrentWorktree(): Promise<Result<{project: string, worktree: string}>>\n\nFunctionality:\n- Two modes:\n  1. With args: w --copy-pr-link <project> <worktree>\n  2. Without args: w --copy-pr-link (detect from cwd)\n- Detect PR using PRDetector\n- Format link using PRLinkFormatter\n- Copy to clipboard using clipboard utility\n- Show success message with preview\n\nOutput:\n‚úì Copied to clipboard: üê≠ [Fix login bug](https://github.com/user/repo/pull/123)",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). CopyPRLinkCommand is a nice productivity feature for sharing PR links in formatted markdown.",
			"acceptanceCriteria": [
				"CopyPRLinkCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Support mode with project/worktree args",
				"Support mode without args (detect from cwd)",
				"detectCurrentWorktree resolves cwd to project/worktree",
				"Use PRDetector to find PR",
				"Use PRLinkFormatter to format link",
				"Use clipboard utility to copy",
				"Show success message with preview",
				"Handle no PR found gracefully",
				"Handle clipboard failures gracefully",
				"Unit tests for both modes",
				"Unit tests for PR not found",
				"Unit tests for clipboard failure",
				"Integration with all dependent modules"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3",
				"story-8",
				"story-10",
				"story-12",
				"story-15"
			],
			"attempts": []
		},
		{
			"id": "story-25",
			"title": "Command: ConfigCommand implementation",
			"description": "Implement --config command for configuration management.\n\nsrc/commands/ConfigCommand.ts:\n- execute(subcommand?: string, ...args: string[]): Promise<Result<void>>\n- handleProjectsDir(path: string): Promise<Result<void>>\n- handleList(): Promise<Result<void>>\n- handleReset(): Promise<Result<void>>\n- handleDeprecated(option: string): void\n\nSubcommands:\n- w --config projects <path> ‚Üí set projects directory\n- w --config list ‚Üí show current config\n- w --config reset ‚Üí reset to defaults\n- w --config setup_script <path> ‚Üí deprecated (show migration message)\n- w --config archive_script <path> ‚Üí deprecated (show migration message)\n\nDeprecation message for scripts:\n'setup_script and archive_script are now configured per-repository.\nUse: w --setup-script <repo> <path>'\n\nList output:\nConfiguration:\n  Projects directory: ~/development\n  Recent history: 50 entries",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). ConfigCommand manages global settings and must guide users through the script config migration.",
			"acceptanceCriteria": [
				"ConfigCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Implement 'projects <path>' subcommand",
				"Implement 'list' subcommand",
				"Implement 'reset' subcommand",
				"Show deprecation message for 'setup_script' and 'archive_script'",
				"Validate paths before saving",
				"Use ConfigManager for operations",
				"Use OutputFormatter for display",
				"Unit tests for all subcommands",
				"Unit tests for invalid paths",
				"Unit tests for deprecated options",
				"Unit tests for list output",
				"Unit tests for reset confirmation"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-4",
				"story-15",
				"story-16"
			],
			"attempts": []
		},
		{
			"id": "story-26",
			"title": "Command: UpdateCommand implementation",
			"description": "Implement --update command for self-updating.\n\nsrc/commands/UpdateCommand.ts:\n- execute(options?: UpdateOptions): Promise<Result<void>>\n- checkForUpdate(): Promise<Result<{available: boolean, latestVersion: string}>>\n- downloadUpdate(version: string): Promise<Result<string>>\n- installUpdate(downloadPath: string): Promise<Result<void>>\n- createBackup(): Promise<Result<string>>\n\nFunctionality:\n- Check GitHub for latest release\n- Compare with current version\n- Download from GitHub raw URL\n- Create backup of current binary/script\n- Replace binary/script with new version\n- Verify update succeeded\n- Support --check flag (just check, don't update)\n\nOutput:\nCurrent version: 1.6.0\nLatest version: 1.7.0\nDownloading update...\nBackup created: ~/.local/share/worktree-wrangler/backup/w-1.6.0\nUpdate installed successfully!\nRun 'w --version' to verify.",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). UpdateCommand enables seamless updates without manual intervention.",
			"acceptanceCriteria": [
				"UpdateCommand.ts created in src/commands/",
				"File stays under 250 lines",
				"Check GitHub API for latest release",
				"Compare versions (semver)",
				"Download from GitHub raw URL",
				"Create backup before updating",
				"Replace binary/script atomically",
				"Verify update succeeded",
				"Support --check flag (dry run)",
				"Handle network failures gracefully",
				"Handle permission errors gracefully",
				"Unit tests with mocked GitHub API",
				"Unit tests for version comparison",
				"Unit tests for backup creation",
				"Unit tests for update failures",
				"UpdateOptions type exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-3",
				"story-15",
				"story-16"
			],
			"attempts": []
		},
		{
			"id": "story-27",
			"title": "Command: Base repository operations (w <project> -)",
			"description": "Extend WorktreeCommand to support base repository operations.\n\nsrc/commands/BaseRepoCommand.ts (or extend WorktreeCommand.ts):\n- executeInBaseRepo(project: string, command?: string[]): Promise<Result<void>>\n- switchToBaseRepo(project: string): Promise<Result<void>>\n\nFunctionality:\n- w <project> - ‚Üí change to base repo directory\n- w <project> - <command> ‚Üí execute command in base repo\n- Resolve project path using RepositoryResolver\n- Track usage (optional for base repo)\n\nExamples:\n- w myproject - ‚Üí cd to ~/development/myproject\n- w myproject - git pull ‚Üí run git pull in base repo\n- w myproject - code . ‚Üí open VS Code in base repo",
			"priority": "medium",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.7 (Commands). Base repo operations complete the worktree workflow by allowing quick access to the main repository.",
			"acceptanceCriteria": [
				"BaseRepoCommand.ts created (or WorktreeCommand extended)",
				"File stays under 250 lines",
				"Support 'w <project> -' to switch to base repo",
				"Support 'w <project> - <command>' to execute in base repo",
				"Use RepositoryResolver to find project",
				"Handle non-existent projects gracefully",
				"Track usage in recent file (optional)",
				"Unit tests for switching to base repo",
				"Unit tests for command execution in base repo",
				"Unit tests for non-existent projects",
				"Integration with RepositoryResolver",
				"Clear error messages for invalid projects"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-7",
				"story-15",
				"story-23"
			],
			"attempts": []
		},
		{
			"id": "story-28",
			"title": "CLI Entry Point: CommandRouter and main entry",
			"description": "Implement command routing and CLI entry point.\n\nsrc/cli/CommandRouter.ts:\n- route(args: string[]): Promise<Result<void>>\n- parseArguments(args: string[]): ParsedCommand\n- validateCommand(parsed: ParsedCommand): Result<void>\n\nsrc/index.ts:\n- main(): Promise<void>\n- setupDependencies(): Dependencies\n- handleExit(result: Result<void>): number\n\nFunctionality:\n- Parse command-line arguments\n- Route to appropriate command handler\n- Handle --help, --version flags\n- Handle positional arguments (project, worktree)\n- Handle command execution mode\n- Set up dependency injection\n- Handle exit codes (0 for success, 1 for error)\n- Catch and format uncaught errors\n\nArgument patterns:\n- w ‚Üí show help\n- w --help ‚Üí HelpCommand\n- w --version ‚Üí VersionCommand\n- w --list ‚Üí ListCommand\n- w --config ... ‚Üí ConfigCommand\n- w <project> <worktree> ‚Üí WorktreeCommand\n- w <project> <worktree> <command> ‚Üí WorktreeCommand with execution\n- w <project> - ‚Üí BaseRepoCommand\n- w --cleanup ‚Üí CleanupCommand\n- etc.",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 5.8 (CLI Entry Point). The router ties everything together and must handle all command patterns correctly.",
			"acceptanceCriteria": [
				"CommandRouter.ts created in src/cli/",
				"index.ts created in src/",
				"Each file stays under 250 lines",
				"parseArguments handles all command patterns",
				"route() dispatches to correct command handler",
				"Dependency injection setup in main()",
				"Handle --help and --version flags",
				"Handle positional arguments correctly",
				"Handle command execution mode",
				"Set exit codes (0 success, 1 error)",
				"Catch and format uncaught errors",
				"Unit tests for all argument patterns",
				"Unit tests for invalid arguments",
				"Unit tests for routing logic",
				"Unit tests for exit code handling",
				"ParsedCommand and Dependencies types exported"
			],
			"dependencies": [
				"story-1",
				"story-2",
				"story-17",
				"story-18",
				"story-19",
				"story-20",
				"story-21",
				"story-22",
				"story-23",
				"story-24",
				"story-25",
				"story-26",
				"story-27"
			],
			"attempts": []
		},
		{
			"id": "story-29",
			"title": "Integration Tests: Multi-module workflow testing",
			"description": "Create integration tests for complex workflows spanning multiple modules.\n\ntests/integration/worktree-lifecycle.test.ts:\n- Test complete worktree creation workflow\n- Test worktree removal with archive script\n- Test cleanup of merged PRs\n\ntests/integration/config-management.test.ts:\n- Test config changes and persistence\n- Test script configuration per repo\n\ntests/integration/pr-detection.test.ts:\n- Test PR detection across all 4 methods\n- Test with real gh CLI responses (mocked)\n\nUse temporary git repositories for testing.\nTest workflows:\n1. Create worktree ‚Üí run setup script ‚Üí track usage ‚Üí switch\n2. Detect PR ‚Üí format link ‚Üí copy to clipboard\n3. List worktrees ‚Üí cleanup merged ‚Üí verify removal\n4. Configure projects dir ‚Üí create worktree ‚Üí verify location",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 6 (Testing Strategy). Integration tests verify that modules work together correctly.",
			"acceptanceCriteria": [
				"Integration test files created in tests/integration/",
				"No file length limit for test files",
				"Test complete worktree creation workflow",
				"Test worktree removal with archive script",
				"Test cleanup of merged PRs",
				"Test config changes and persistence",
				"Test script configuration per repo",
				"Test PR detection with all 4 methods",
				"Use temporary git repos for testing",
				"Mock gh CLI responses",
				"Tests run in CI environment",
				"All integration tests pass",
				"Tests clean up temporary files/repos",
				"Tests are deterministic and reproducible"
			],
			"dependencies": [
				"story-3",
				"story-4",
				"story-5",
				"story-6",
				"story-7",
				"story-8",
				"story-9",
				"story-10",
				"story-11",
				"story-12",
				"story-13",
				"story-14"
			],
			"attempts": []
		},
		{
			"id": "story-30",
			"title": "End-to-End CLI Tests: Full command execution testing",
			"description": "Create end-to-end tests that spawn the actual CLI process.\n\ntests/e2e/cli.test.ts:\n- Spawn CLI process with arguments\n- Verify stdout/stderr output\n- Verify exit codes\n- Verify side effects (files created, git operations)\n\nTest scenarios:\n1. w --help (verify help text)\n2. w --version (verify version output)\n3. w --list (verify worktree listing)\n4. w myproject test-wt (create worktree)\n5. w --rm myproject test-wt (remove worktree)\n6. w --cleanup --dry-run (dry run cleanup)\n7. w --config projects /tmp/test (config change)\n8. w nonexistent project (error handling)\n\nUse real git repos in /tmp for testing.\nClean up after each test.",
			"priority": "high",
			"passes": false,
			"info": "Reference: TYPESCRIPT-PORT-DESIGN.md Section 6 (Testing Strategy). E2E tests verify the CLI works correctly as users would actually use it.",
			"acceptanceCriteria": [
				"E2E test file created in tests/e2e/",
				"No file length limit for test files",
				"Spawn actual CLI process for each test",
				"Verify stdout/stderr output",
				"Verify exit codes (0 success, 1 error)",
				"Verify side effects (files, git operations)",
				"Test all major commands (help, version, list, create, remove, cleanup, config)",
				"Test error scenarios (invalid args, missing projects)",
				"Use temporary git repos in /tmp",
				"Clean up after each test",
				"Tests run in CI environment",
				"All E2E tests pass",
				"Tests cover happy paths and error paths"
			],
			"dependencies": [
				"story-28",
				"story-29"
			],
			"attempts": []
		}
	]
}
